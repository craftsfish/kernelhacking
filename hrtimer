hrtimer_interrupt
HRTIMER_ACTIVE_HARD
HRTIMER_ACTIVE_SOFT

删除hrtimer的时候，如果base在当前CPU上的，需要reprogram时钟，如果不是当前CPU，那么目标CPU上的时钟已经armed，如果该hrtimer是最早的，到期不处理，重新reprogram时钟即可，如果不是最早的，无需处理。
增加hrtimer的时候，默认base到当前CPU上，如果base在其他CPU，必须确保expire时间在对应的时钟事件之后，因为我们没有办法rearm其他CPU上的时钟。

hrtimers_dead_cpu调用的时候一定是在非scpu上的？因为__migrate_hrtimers只能将timer从remote迁移到当前cpu上？
migrate完成后为什么只reprogram了soft timer没有处理hard? {
	通过调用__hrtimer_peek_ahead_timers强行触发已过期的timer并重新program tick event
}
