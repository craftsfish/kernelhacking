--------------------------------------------------------------------------------
文档 {
	https://docs.fedoraproject.org/en-US/Fedora/20/html/Power_Management_Guide/index.html
	https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/performance_tuning_guide/index
}
--------------------------------------------------------------------------------
源代码 {
	perf
	ftrace
	binder
	lockstat
	lockdep
}
--------------------------------------------------------------------------------
调研 {
	useless work detection
	关键路径识别（非关键路径的并发线程）
	coz在非CPU资源优化上的应用
	如何评估一个工具的overhead
	并发火焰图
	memcached
	{
		cache命中率，到具体的文件
		关键文件识别
	}
	如何捕获新进程的所有thread? {
		ftrace的set_event_pid作为参考
		task_newtask(根据clone_flag做进一步筛选)(构建tid bitmap)
	}
	perf数据都是什么时候写入的?
	perf代码如何调试？
	kgdb使用
	buildid原理
	uprobe如何使用
	tracing_on默认值谁设定的？
}
--------------------------------------------------------------------------------
patch {
	ftrace {
		each time a trace is added, record comm is enabled, record happens when switch/record
		while trace is added, cat trace_pipe might be actived and comm is not record yet
		a more resonable solution should record comm before trace is commited, and disable current task record during a schedule slice
	}
	Documentation/trace/histogram.rst {
		1030, 字符串filter要加""
		确认代码解析逻辑
		1155, 需要改成>>
		1171, 应该是disable_event
	}
	drivers/devfreq/devfreq.c {
		如果devfreq必须有governor的话，卸载成功的前提必须是当前governor已经无人使用
	}
}
--------------------------------------------------------------------------------
其他 {
	critical game file loader
	https://medium.com/@copyconstruct/best-of-2019-in-tech-talks-bac697c3ee13
	aosp工具梳理
	aosp工具参与
	内部项目
	perf功能移植
	bpf工具移植
	man perf_event_open
	workqueue, psi, scheduler, ftrace, debug object
	Leetcode
	modify comment of propagate_mnt, attach_recursive_mnt
	perf, cgroup, bpf, flame grpah, Perfetto
	redhat, microsoft, alibaba, opensuse, amazon
	http://www.brendangregg.com/overview.html
	The Art of Capacity Planning
	[crash](https://people.redhat.com/anderson/)
	Operating System Concepts, 10th Edition; Operating Systems, Internals and Design Principles
	Linux Driver Development for Embedded Processors
	H: Operating System Concepts, 10th Edition
	M: Operating Systems, Internals and Design Principles
	O: Linux Driver Development for Embedded Processors
	tools for kernel stack and function graph
}

strace {
	无埋点获取几乎任何内核代码执行信息
	只能追踪系统调用，而文件的打开不仅仅通过系统调用，内核可以直接打开文件
	strace只能追踪特定的应用信息，不能追踪系统的整体信息
	strace + command才能分析具体的应用或者attach到pid，使用am命令行启动应用时，分析的是am的系统调用，而attach到pid则要求应用必须已经起来，无法抓到完整的信息
	strace只能分析用户空间的信息，我们关注的是内核态的信息，cache是否命中无法通过strace获取
	inode是否命中
	https://en.wikipedia.org/wiki/Heisenbug
	https://www.kernel.org/doc/html/latest/dev-tools/kunit/index.html#why-kunit
	KUnit is fast. Excluding build time, from invocation to completion KUnit can run several dozen tests in only 10 to 20 seconds; this might not sound like a big deal to some people, but having such fast and easy to run tests fundamentally changes the way you go about testing and even writing code in the first place. Linus himself said in his git talk at Google:

“… a lot of people seem to think that performance is about doing the same thing, just doing it faster, and that is not true. That is not what performance is all about. If you can do something really fast, really well, people will start using it differently.”

https://source.android.com/devices/tech/debug/ftrace#dftrace	
When systrace and standard ftrace are insufficient, there is one last recourse available: dynamic ftrace. Dynamic ftrace involves rewriting of kernel code after boot, and as a result it is not available in production kernels for security reasons.
However, every single difficult performance bug in 2015 and 2016 was ultimately root-caused using dynamic ftrace. It is especially powerful for debugging uninterruptible sleeps because you can get a stack trace in the kernel every time you hit the function triggering uninterruptible sleep. You can also debug sections with interrupts and preemptions disabled, which can be very useful for proving issues.
}
